"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpWaitStrategy = void 0;
const wait_strategy_1 = require("./wait-strategy");
const node_fetch_1 = __importDefault(require("node-fetch"));
const https_1 = __importDefault(require("https"));
const common_1 = require("../common");
const container_runtime_1 = require("../container-runtime");
class HttpWaitStrategy extends wait_strategy_1.AbstractWaitStrategy {
    path;
    port;
    protocol = "http";
    method = "GET";
    headers = {};
    predicates = [];
    _allowInsecure = false;
    readTimeout = 1000;
    constructor(path, port) {
        super();
        this.path = path;
        this.port = port;
    }
    forStatusCode(statusCode) {
        this.predicates.push(async (response) => response.status === statusCode);
        return this;
    }
    forStatusCodeMatching(predicate) {
        this.predicates.push(async (response) => predicate(response.status));
        return this;
    }
    forResponsePredicate(predicate) {
        this.predicates.push(async (response) => predicate(await response.text()));
        return this;
    }
    withMethod(method) {
        this.method = method;
        return this;
    }
    withHeaders(headers) {
        this.headers = { ...this.headers, ...headers };
        return this;
    }
    withBasicCredentials(username, password) {
        const base64Encoded = Buffer.from(`${username}:${password}`).toString("base64");
        this.headers = { ...this.headers, Authorization: `Basic ${base64Encoded}` };
        return this;
    }
    withReadTimeout(readTimeout) {
        this.readTimeout = readTimeout;
        return this;
    }
    usingTls() {
        this.protocol = "https";
        return this;
    }
    allowInsecure() {
        this._allowInsecure = true;
        return this;
    }
    async waitUntilReady(container, boundPorts) {
        common_1.log.debug(`Waiting for HTTP...`, { containerId: container.id });
        const client = await (0, container_runtime_1.getContainerRuntimeClient)();
        await new common_1.IntervalRetry(this.readTimeout).retryUntil(async () => {
            try {
                const url = `${this.protocol}://${client.info.containerRuntime.host}:${boundPorts.getBinding(this.port)}${this.path}`;
                return await (0, node_fetch_1.default)(url, {
                    method: this.method,
                    timeout: this.readTimeout,
                    headers: this.headers,
                    agent: this.getAgent(),
                });
            }
            catch {
                return undefined;
            }
        }, async (response) => {
            if (response === undefined) {
                return false;
            }
            else if (!this.predicates.length) {
                return response.ok;
            }
            else {
                for (const predicate of this.predicates) {
                    const result = await predicate(response);
                    if (!result) {
                        return false;
                    }
                }
                return true;
            }
        }, () => {
            const message = `URL ${this.path} not accessible after ${this.startupTimeout}ms`;
            common_1.log.error(message, { containerId: container.id });
            throw new Error(message);
        }, this.startupTimeout);
        common_1.log.debug(`HTTP wait strategy complete`, { containerId: container.id });
    }
    getAgent() {
        if (this._allowInsecure) {
            return new https_1.default.Agent({
                rejectUnauthorized: false,
            });
        }
    }
}
exports.HttpWaitStrategy = HttpWaitStrategy;
//# sourceMappingURL=http-wait-strategy.js.map